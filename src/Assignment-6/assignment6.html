<!DOCTYPE html>
<html>
<head>
	<title></title>
	<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
	<meta http-equiv="Pragma" content="no-cache" />
	<meta http-equiv="Expires" content="0" />
	<script src="bundle.js" type="text/javascript"></script>
</head>

<body>
	<div id="container">

	<!-- Start your code from here -->
	<main>
		<form class="form">
			<div id="char">
				<p class="dec" ><label class="label">Character:</label><br><span class="count" ><b>00</b></span></p>
				<p class="dec"><label class="label">Threads:</label><br><span class="threadcount"><b>00</b></span></p>		
			</div>
			<div class="container">
				<textarea class="text" onkeyup="textinfo(this)" required="" wrap="soft" placeholder="The character limit for each thread is 275" ></textarea>
				<button type="submit" class="btn">Thread</button>
			</div>
			
		</form>	
		<div class="thread-box">
			<div class="thread">
				<span class="sl"></span><br>
				âœ¨<br>
				Your threads will be here.ðŸ”¥ <br><br>
				The character limit for each thread is 275. <br><br>
			</div>
		</div>
	</main>	
	
	
	
	<!-- End your code -->

	</div>

	<script type="text/javascript">
/*
		let input=document.getElementById('charcount')
		function charcountupdate(e){
			count=e.value.length
			input.innerHTML=e.value.length;
		}
*/			


	const dom=(s)=>document.querySelector(s);
	const form=dom('.form')
	const charcount=dom('.count')
	const threadcount=dom('.threadcount');
	const threadbox=dom('.thread-box');
	const size=275;
	let threadArr=[]
	function textinfo(e){
		let length=e.value.length;
		charcount.innerHTML=length;
		threadcount.innerHTML=Math.ceil(length/size);
		length>size ? (e.style.color='white'): (e.style.color='white');
	}
	function displaythread(listParent,arr=[]){
		listParent.innerHTML=arr.map((el,i)=>{
			return `
			<artical class='thread' data-index="${i}">
				<div class='tools'>
					<span class=index>${i<9? '0'+(i+1):i+1}</span>
					<span class='close' data-index='${i}'>X</span
				</div>
				<p class='thread-str'>
					${el}
				</p>
			</artical>			
			`;
		}).join('')
	}
function cleanthread(s){
	let splitonwhitespace=s.split(' ');
	let result=[]
	let totallength=0;
	let sentance=' ';
	for(let i=0;i<splitonwhitespace.length;i++){
		let curword=splitonwhitespace[i];
		let curwordlength=curword.length;

		sentance+=curword+' ';
		totallength+=curwordlength+1;
		if (totallength>=size){
			sentance=sentance.trim();
			let lengthdiff=sentance.length-size;
			if(lengthdiff>0){
				let lastindexofwhitespace=sentance.lastIndexOf(' ');
				sentance=sentance.slice(0,lastindexofwhitespace);
				i--
			}
			result.push(sentance);
			totallength=0;
			sentance='';
		}
		if(i==splitonwhitespace.length-1 && totallength<=size &&sentance!==''){
			result.push(sentance.trim());
		}
	}
	
	return result
}
function thread(ev){
	ev.preventDefault();
	const thread=dom('.thread');
	threadArr=cleanthread(dom('.text').value)
	displaythread(threadbox,threadArr);
}
form.addEventListener("submit",thread);


function deleteThread(e) {
	e.preventDefault();
	const [el,index] = [e.target,e.target.dataset.index];
	let txt = e.target.dataset.para;

	if (el.classList.contains("close")) {

		threadArr.splice(index, 1);

		displaythread(threadbox, threadArr);
	}
}

threadbox.addEventListener("click", deleteThread);
	</script>

</body>
<script>
/* DO NOT EDIT THIS CODE- WRITTERN TO PREVENT CSS CACHING */	  
	// Get HTML head element
	var head = document.getElementsByTagName('HEAD')[0]; 
	// Create new link Element
	var link = document.createElement('link');
	// set the attributes for link element 
	link.rel = 'stylesheet'; 
	link.type = 'text/css';
	link.href = './assignment6.css?v='+ new Date().getTime(); 
	// Append link element to HTML head
	head.appendChild(link); 
	/* DO NOT EDIT THIS CODE- WRITTERN TO PREVENT CSS CACHING */	  
</script> 
</html>
